import os
import sys
import code
import math
import random
from itertools import permutations, combinations, accumulate, reduce

#-----------------------------------------------------------------------------#
#                         PEARLS & FREQUENT REFERENCE                         #
#-----------------------------------------------------------------------------#

#==== gotchas
# make an NxM matrix properly
matrix = [[0]*ncols for _ in range(nrows)]  # BAD_MAT = [[0] * ncols] * nrows # DONT


#==== comprehensions
double_for = [(i,j) for j in range(5) for i in range(3)] # [(0,0), (1,0), ..., (2,4)]
with_if   = [i for i in range(20) if i & 1] # odds
set_comp  = set(i for i in range(20) if i & 1)
dict_comp = {i: i**2 for i in range(20) if i & 1}


#==== COPY
copy.copy(x)     # shallow copy: you almost never want this (still has references)
copy.deepcopy(x) # deep copy: what you think of when you think copy, FULL recursive copy



#-----------------------------------------------------------------------------#
#                                   RECIPES                                   #
#-----------------------------------------------------------------------------#

#------------------
class AttrDict(dict):
    # just a dict mutated/accessed by attribute instead index
    # NB: not pickleable
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


#==== strip punctuation from string
def translate_strip(s):
    table = str.maketrans({key: None for key in string.punctuation})
    t = s.translate(table)
    return t

def re_strip(s): # marginally faster than translate
    t = re.sub(r'[^\w\s]', '', s)
    return t

#==== matrix
def mk_matrix(N, M, fill=0):
    mat = [[fill] * M for _ in range(N)]
    return mat

def dot_prod(v1, v2):
    return sum(map(operator.mul, v1, v2))

#==== combinatorial shit
def powerset(S):
    pS = []
    combo = lambda i: set(itertools.combinations(S, i))
    for i in range(len(S)):
        pS.append(combo(i))
    return pS


#-----------------------------------------------------------------------------#
#                                    NEAT                                     #
#-----------------------------------------------------------------------------#

#==== XKCD-style passhrase
def gen_passphrase(num_words=4, sep=' '):
    import re
    from secrets import choice
    with open('/usr/share/dict/words') as dwords:
        words = [w.strip() for w in dwords]
        pwords = sep.join(choice(words) for i in range(num_words))
        passphrase = re.sub(r'[^\w\s]', '', pwords).lower()
    return passphrase


#-----------------------------------------------------------------------------#
#                                    TOOLS                                    #
#-----------------------------------------------------------------------------#

#==== ITERTOOLS
#https://docs.python.org/3/library/itertools.html

# infinite iterators (basically for generators)
cnt = itertools.count() # (c.__next__(), c.__next__()) == (0,1)
cyc = itertools.cycle('abc') # --> a b c a b c a b...
five_tens = list(itertools.repeat(10, 5)) # [10,10,10,10,10]

# COMBINATORIC

# Permutations, nPr
list(itertools.permutations([2,5,0,1]))
#   r = None         r = 2
# [(2, 5, 0, 1),  # [(2, 5),
#  (2, 5, 1, 0),  #  (2, 0),
#  (2, 0, 5, 1),  #  (2, 1),
#  (2, 0, 1, 5),  #  (5, 2),
#  (2, 1, 5, 0),  #  (5, 0),
#  (2, 1, 0, 5),  #  (5, 1),
#  (5, 2, 0, 1),  #  (0, 2),
#  (5, 2, 1, 0),  #  (0, 5),
#  (5, 0, 2, 1),  #  (0, 1),
#  (5, 0, 1, 2),  #  (1, 2),
#  (5, 1, 2, 0),  #  (1, 5),
#  (5, 1, 0, 2),  #  (1, 0)]
#  (0, 2, 5, 1),  #
#  (0, 2, 1, 5),  #
#  (0, 5, 2, 1),  #
#  (0, 5, 1, 2),  #
#  (0, 1, 2, 5),  #
#  (0, 1, 5, 2),  #
#  (1, 2, 5, 0),  #
#  (1, 2, 0, 5),  #
#  (1, 5, 2, 0),  #
#  (1, 5, 0, 2),  #
#  (1, 0, 2, 5),  #
#  (1, 0, 5, 2)]  #

# Combinations nCr
list(itertools.combinations([2,5,0,1], 2))
[(2, 5), (2, 0), (2, 1), (5, 0), (5, 1), (0, 1)]




#==== FUNCTOOLS
#https://docs.python.org/3/library/functools.html
@functools.lru_cache(maxsize=5)




#-----------------------------------------------------------------------------#
#                                  OS  SH                                     #
#-----------------------------------------------------------------------------#

#==== MIMETYPES

#-----------------------------------------------------------------------------#
#                              DATA STRUCTURES                                #
#-----------------------------------------------------------------------------#

#==== ARRAY

#==== COLLECTIONS

#==== TYPES.SimpleNamespace


#-----------------------------------------------------------------------------#
#                                 ALGORITHMS                                  #
#-----------------------------------------------------------------------------#

#==== HEAPQ

#==== BISECT



#-----------------------------------------------------------------------------#
#                                   NUMERIC                                   #
#-----------------------------------------------------------------------------#
# honorable mentions: decimal(for float stuff), cmath(math for complex nums)
#==== MATH
# math: ceil, floor, fabs, fmod, fsum, isclose, isinf isnan isfinite
#       exp, log, log1p, sqrt, sin cos tan, asin/cos/tan/tan2
#       sinh tanh cosh, asinh/cosh/tanh
math.factorial(x) # x!
math.log(16, 4) == 2.0
math.gcd(42, 24) == math.gcd(18, 6) == 6
math.expm1(x) # exp(x) - 1, without loss of precision
math.degrees(angle) # radians --> degrees
math.radians(angle) # degrees --> radians

def phi(x): # cumulative distrib func for the standard norm dist; erf <-- error func
    return (1.0 + math.erf(x / math.sqrt(2.0))) / 2.0

# constants
math.pi  # 3.141592...
math.e   # 2.718281...
math.tau # 6.283185... # circle constant == 2pi, ratio circumference to radius
math.inf # floating point pos infinity == float('inf')
math.nan # fp for NaN == float('nan')


#=== FRACTIONS, DECIMALS
from fractions import Fraction
Fraction(16, -10) == Fraction(-8, 5) # Fraction automatically reduces to rhs
Fraction('3/7')   # Fraction(3, 7)
Fraction('-.125') # Fraction(-1, 8)
Fraction('7e-6')  # Fraction(7, 1000000)
Fraction(2.25)    # Fraction(9, 4)
Fraction(.5) + 2.234  # --> 2.734
from decimal import Decimal
Fraction(1.1) # Fraction(2476979795053773, 2251799813685248)
Fraction(Decimal('1.1')) # Fraction(11, 10)

#==== STATISTICS
statistics.mean(nums)   # what you think
statistics.median(nums) # yep
statistics.median_low([1,3,5,7]) == 3 # USE THIS FOR non-numeric DATA
statistics.median_high([1,3,5,7]) == 5 # USE THIS FOR non-numeric DATA
statistics.variance(data, xbar=None) # xbar is mean of data
statistics.stdev(data, xbar=None) # xbar is mean of data


#==== RANDOM
k = random.randint(a, b) # a <= k <= b; alias randrange(a, b+1)
x = random.random()      # 0.0 <= x < 1.0
y = random.uniform(a, b) # a <= y < b
k = random.randrange(5)  # k in [0,1,2,3,4]; (start, stop) also
random.gauss(mu, sigma) # exactly what you think
# seq
random.choice(seq) # return random elem from seq
random.choices(seq, weights=None, k=3) # select k elem WITH REPLACEMENT
random.sample(seq, k) # select k unique elem from seq, WITHOUT REPLACE
random.shuffle(seq) # shuffle seq IN PLACE


#-----------------------------------------------------------------------------#
#                                   STRING                                    #
#-----------------------------------------------------------------------------#

#==== str
b = 'baz'; i = 7; my_float = 2**(1/2);
print(f'{my_float}') # 1.4142135623730951
print(f'{my_float: .3f}') # 1.414
print(f'|{b:<12}|')  # ---> |baz         |
print(f'|{b:^12}|')  # ---> |    baz     |
print(f'|{b:>12}|')  # ---> |         baz|
print(f'|{b:*<12}|') # ---> |baz*********|
print(f'|{b:0^12}|') # ---> |0000baz00000|
print(f'|{b:^>12}|') # ---> |^^^^^^^^^baz|
print(f'{num:03}')   # ---> 007
print(f'{11:03}')    # ---> 011

#==== STRING
import string
# constants
string.ascii_letters == 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.ascii_lowercase == 'abcdefghijklmnopqrstuvwxyz'
string.ascii_uppercase == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.digits == '0123456789'
string.hexdigits == '0123456789abcdefABCDEF'
string.punctuation == '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
string.whitespace == ' \t\n\r\x0b\x0c'


#-----------------------------------------------------------------------------#
#                                  STL; MISC                                  #
#-----------------------------------------------------------------------------#
"""
Overview of modules available in STL (but not expanded here)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

difflib : matching sequences
    eg difflib.get_close_matches(w, seq) gets words close to w in seq
    can do alot with difflib, can do CLI stuff too

struct : interpret bytes as packed binary data
    have used before for unpacking datasets stored as binaries (nbody sims)

abc : abstract base classes






"""

#=== DATETIME
d = datetime.datetime.now().date() # datetime.date(2019, 2, 28)
d.year; d.month; d.day; # 2019; 2; 28;
str(d) # '2019-02-28'


#==== SECRETS
# random stuff for crypt
secrets.token_hex(12) # '6b0394da5fa4ac285ea8592c'
secrets.token_urlsafe(12) # 'ZuXCa8ummIt8V1-h'
secrets.token_urlsafe()   # 'cZOZlQ4mdwSgfoToQmeHupvRuAVrX-FeG8hSRbeJkrU'



#==== ops
# bitwise
int.bit_length(6) == 3 == len('0b110'[2:])
x | y  # OR
x ^ y  # XOR
x & y  # AND
x << y; x >> y; # shifts
~x # twos comp (bits inverted) == -x - 1

# bytes
(1024).to_bytes(4, 'big') # b'\x00\x00\x04\x00'; hex(1024): 0x400
hex(1000) # '0x3e8'
(1000).to_bytes(4, 'little') # b'\xe8\x03\x00\x00'




#==== BUILTINS
id(s) # returns unique integer identity of object s
divmod(8, 5) == (1, 3) == (8 //5, 8 % 5)
ord('a') == 97 and chr(97) == 'a'
any([0,0,1,0]) == not all([0,0,1,0]) == True

# iter over seq
list(filter(lambda i: i & 1 == 0, [1,2,3,4,5,6])) == [2,4,6]
list(map(lambda i: i - 1, [1,2,3,4])) == [0,1,2,3]

#-----------------------------------------------------------------------------#
#                              PROCESS & THREAD                               #
#-----------------------------------------------------------------------------#
