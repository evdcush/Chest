import os
import sys
import code
import math
import pickle
import random
import IPython
from itertools import permutations, combinations, accumulate, reduce

# built-ins
# =========
# abs
# aiter
# all
# any
# anext
# ascii
# bin
# bool
# breakpoint
# bytearray
# bytes
# callable
# chr
# classmethod
# compile
# complex
# delattr
# dict
# dir
# divmod
# enumerate
# eval
# exec
# filter
# float
# format
# frozenset
# getattr
# globals
# hasattr
# hash
# help
# hex
# id
# input
# int
# isinstance
# issubclass
# iter
# len
# list
# locals
# map
# max
# memoryview
# min
# next
# object
# oct
# open
# ord
# pow
# print
# property
# range
# repr
# reversed
# round
# set
# setattr
# slice
# sorted
# staticmethod
# str
# sum
# super
# tuple
# type
# vars
# zip



#-----------------------------------------------------------------------------#
#                         PEARLS & FREQUENT REFERENCE                         #
#-----------------------------------------------------------------------------#

#==== gotchas
# make an NxM matrix properly:
matrix = [[0]*ncols for _ in range(nrows)]

# BAD_MAT = [[0] * ncols] * nrows   ## DONT! this makes duplicate rows


#==== comprehensions
## with double for-loop, the first for is the inner-loop, and 2nd for is outer
##  eg: [print('foo') for j in range(5) for i in range(3)] is same as
##      for i in range(3):
##          for j in range(5):
##              print('foo')
double_for = [(i,j) for j in range(5) for i in range(3)] # [(0,0), (1,0), ..., (2,4)]
with_if    = [i for i in range(20) if i & 1]       # odds
set_comp   = set(i for i in range(20) if i & 1)    # odds
dict_comp  = {i: i**2 for i in range(20) if i & 1}


#==== COPY
copy.copy(x)     # shallow copy: you ALMOST NEVER want this (still has references)
copy.deepcopy(x) # deep copy: what you think of when you think copy, FULL recursive copy


#==== subprocess
subprocess.run(f'wget {url}', cwd=dst, shell=True) # cwd will exec this command in dst


#==== interact with code
## TWO options: code, and IPython (better)
code.interact(local=dict(globals(), **locals()))
IPython.embed()

# Note, you can also simply breakpoint(); interact
# and you can alias to use ipython shell instead if you put in .pdbrc:
import IPython

alias interacti IPython.embed()


"""
## How to make your 'foo.py' script executable bin

1. put this at the top of script:
#!/usr/bin/env python

2. Make script executable (in terminal):
chmod +x foo.py

3. symlink script to somewhere on path (like user bin):
ln -sf /path/to/foo.py $HOME/.local/bin/foo

4. Call like you would other bins on cli:
$ foo
"hello there"

$ foo airplane
"hello there airplane"
"""



#-----------------------------------------------------------------------------#
#                                   RECIPES                                   #
#-----------------------------------------------------------------------------#

#==== collection/structure
class AttrDict(dict):
    # just a dict mutated/accessed by attribute instead index
    # NB: not pickleable
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


def count(iterable):
    """ count frequency of elements in an iterable (w/o collections) """
    counts = dict()
    for x in iterable:
        counts[x] = 1 + counts.get(x, 0)  ## get returns 0 if x not in counts
    return counts


class Record:
    """ A key:value structure, with comp methods defined on the values """
    def __init__(self, rid, val):
        self.id  = rid
        self.val = val

    def __lt__(self, x): return self.val < x

    def __le__(self, x): return self.val <= x

    def __eq__(self, x): return self.val == x

    def __ge__(self, x): return self.val >= x

    def __gt__(self, x): return self.val > x

    def __str__(self):
        return self.id + ' ' + str(self.val)

### The same thing, but using functools.total_ordering to do comps for you:
@functools.total_ordering
class Record:
    def __init__(self, rid, val):
        self.id  = rid
        self.val = val

    def __lt__(self, x): return self.val < x

    def __eq__(self, x): return self.val == x


#==== algo
def argsort(nums):
    """ get indices that would sort nums """
    # sort enumerated nums on vals
    idx = [i for i, x in sorted(enumerate(nums), key=lambda tup: tup[1])]
    return idx




#==== remove punctuation from string
def rmpunc(s):
    import string
    punc_set = set(string.punctuation)  # for faster lookups
    t = ''.join([c for c in s if c not in punc_set])
    return t


def rmpunc_translate(s):
    table = str.maketrans({key: None for key in string.punctuation})
    t = s.translate(table)
    return t


def rmpunc_re(s): # marginally faster than translate
    t = re.sub(r'[^\w\s]', '', s)
    return t




#==== matrix
def mk_matrix(N, M, fill=0):
    mat = [[fill] * M for _ in range(N)]
    return mat

def dot_prod(v1, v2):
    return sum(map(operator.mul, v1, v2))




#==== permutation stuff
def powerset(S):
    pS = []
    combo = lambda i: set(itertools.combinations(S, i))
    for i in range(len(S)):
        pS.append(combo(i))
    return pS


def ordered_combos(lst):
    """
    >>> ordered_combos([1,2,3,4])
    [[1],
     [1, 2],
     [1, 2, 3],
     [1, 2, 3, 4],
     [2],
     [2, 3],
     [2, 3, 4],
     [3],
     [3, 4],
     [4]]
    """
    idx_slices = itertools.combinations(range(len(lst) + 1), 2)
    combos = []
    for i, j in idx_slices:
        combos.append(lst[i:j])
    return combos




#==== random & mathy
def choice_simple(weights):
    """ return idx selected with probs p from weights """
    total = sum(weights)
    u = random.uniform(0, total)
    psum = 0
    for i, w in enumerate(weights):
        if psum + w >= u:
            return i
        psum += w
    raise Exception('ERROR in choice')


def weighted_mean(nums, weights):
    """ calculate weighted mean """
    num = 0
    den = 0
    for x, w in zip(nums, weights):
        num += x * w
        den += w
    return num / den



#-----------------------------------------------------------------------------#
#                                    NEAT                                     #
#-----------------------------------------------------------------------------#

#==== XKCD-style passhrase
def gen_passphrase(num_words=4, sep=' '):
    import re
    from secrets import choice
    with open('/usr/share/dict/words') as dwords:
        words = [w.strip() for w in dwords]
        pwords = sep.join(choice(words) for i in range(num_words))
        passphrase = re.sub(r'[^\w\s]', '', pwords).lower()
    return passphrase


#-----------------------------------------------------------------------------#
#                                    TOOLS                                    #
#-----------------------------------------------------------------------------#

with open("model_outputs", 'wb') as dfile:  # must be 'wb' !
    pickle.dump(outputs, dfile)

#==== ITERTOOLS
#https://docs.python.org/3/library/itertools.html

# infinite iterators (basically for generators)
cnt = itertools.count() # (c.__next__(), c.__next__()) == (0,1)
cyc = itertools.cycle('abc') # --> a b c a b c a b...
five_tens = list(itertools.repeat(10, 5)) # [10,10,10,10,10]

# COMBINATORIC

# Permutations, nPr
list(itertools.permutations([2,5,0,1]))
#   r = None         r = 2
# [(2, 5, 0, 1),  # [(2, 5),list()
#  (2, 5, 1, 0),  #  (2, 0),
#  (2, 0, 5, 1),  #  (2, 1),
#  (2, 0, 1, 5),  #  (5, 2),
#  (2, 1, 5, 0),  #  (5, 0),
#  (2, 1, 0, 5),  #  (5, 1),
#  (5, 2, 0, 1),  #  (0, 2),
#  (5, 2, 1, 0),  #  (0, 5),
#  (5, 0, 2, 1),  #  (0, 1),
#  (5, 0, 1, 2),  #  (1, 2),
#  (5, 1, 2, 0),  #  (1, 5),
#  (5, 1, 0, 2),  #  (1, 0)]
#  (0, 2, 5, 1),  #
#  (0, 2, 1, 5),  #
#  (0, 5, 2, 1),  #
#  (0, 5, 1, 2),  #
#  (0, 1, 2, 5),  #
#  (0, 1, 5, 2),  #
#  (1, 2, 5, 0),  #
#  (1, 2, 0, 5),  #
#  (1, 5, 2, 0),  #
#  (1, 5, 0, 2),  #
#  (1, 0, 2, 5),  #
#  (1, 0, 5, 2)]  #

# Combinations nCr
list(itertools.combinations([2,5,0,1], 2))
[(2, 5), (2, 0), (2, 1), (5, 0), (5, 1), (0, 1)]


#==== FUNCTOOLS
#https://docs.python.org/3/library/functools.html
@functools.lru_cache(maxsize=5)

# Partial function
# ================
def foo(a, b, c, d='tail'): # NORMAL FUNC
    print(f"a : {a}, b : {b}, c : {c}, d : {d}")

# partial func baz that calls foo with a='bar', b='wow'
>>> baz = partial(foo, 'bar', 'wow') # NB: c arg not provided
>>> baz('dog')         # equivalent to  foo('bar', 'wow', 'dog')
'a : bar, b : wow, c : dog, d : tail'

>>> baz('mamba', 'seer')
'a : bar, b : wow, c : mamba, d : seer'
>>> goof = partial(foo, c=11)   # foo(a, b, 11, d)
>>> goof('hello', 'there')
'a : hello, b : there, c : 11, d : tail'


#==== BISECT
# returns the index where to insert i, assuming L is sorted
L = [-2, 0, 2, 4, 5, 8, 11]
bisect.bisect(L, 6) # ----> 5; L[:5] <= 6, L[5:] > 6
bisect.bisect(L, 1) # ----> 2; L[:2] <= 1, L[2:] > 1
bisect.bisect(L, 5) # ----> 5; L[:5] <= 5, L[5:] > 5
bisect.insort(L, 7) # ----> [-2, 0, 2, 4, 5, 7, 8, 11]



#-----------------------------------------------------------------------------#
#                                  OS  SH                                     #
#-----------------------------------------------------------------------------#

#==== cool os lib stuff
term_size = os.get_terminal_size()
print(term_size.columns)  # 173
print(term_size.lines)    # 21


#==== OS / GLOB / Files & Dirs

#== Glob
# get all numbered files
glob.glob('./[0-9].*')

# get all pdfs from curdir tree
glob.glob('**/*.pdf', recursive=True)  # '**' needed for recursive globs

# get all pdfs from curdir with abspaths
[os.path.abspath(g) for g in glob.glob('./**/*.pdf', recursive=True)]


#==== MIMETYPES

#-----------------------------------------------------------------------------#
#                              DATA STRUCTURES                                #
#-----------------------------------------------------------------------------#

####  SET  ####
A = set(['a', 'b', 'c'])
P = set([1,2,3,4])
Q = set([3,4,5,6])
R = set([1,2,3,4,5,6])

# NB: Assume each update op is on a copy of original

# Misc
A.add('x') # A no {'a', 'b', 'c', 'x'}
A.remove('z') # KeyError; remove raises KeyError if not present
A.discard('z') # OKAY (no keyerror), discard removes IF present

A.isdisjoint(P) == (A & P == set()) # no elems of A in P

# Subset and proper subset
P <= R and P.issubset(R) and P < R # True; P is a proper subset of R
P <= P and not P < P # P is a subset of P; but NOT a proper subset

# Superset
R >= Q and R.issuperset(Q) # True; R is a superset of Q
R > R # False; R is NOT a proper subset of itself (R >= R, but not R != R)

# Union
P | Q == P.union(Q) == R # {1,2,3,4,5,6}
P |= ['foo', 'bar', 3, 11] # P == {1,2,3,4,11,'foo','bar'}
P.update({'a': True, 'fog': 'cool', 7: 'lucky?'}) # P == {1,2,3,4,7,'a','cool'}

# Intersection
P & Q == P.intersection(Q) == set([3,4])
P &= set([9,4,1]) # {1,4}
P.intersection_update([6,5,1,3,1]) # {1, 3}

# Difference  (order matters !)
R - Q == R.difference(Q) == set([1,2])
A -= ['f', 'o', 'c', 'b'] # {'a'}
A.difference_update(Q) # {'a', 'b', 'c'}

# XOR
P ^ Q == P.symmetric_difference(Q) == set([1,2,5,6])
P ^= Q # {1,2,5,6}
P.symmetric_difference_update(R) # {5,6}


#==== ARRAY

#==== COLLECTIONS

# defaultdict : takes callable with init and defaults that value for missing key
s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = defaultdict(list)
for k, v in s:
    d[k].append(v)


#==== TYPES.SimpleNamespace


#-----------------------------------------------------------------------------#
#                                 ALGORITHMS                                  #
#-----------------------------------------------------------------------------#

#==== HEAPQ


#==== SORT & MAX



#-----------------------------------------------------------------------------#
#                                   NUMERIC                                   #
#-----------------------------------------------------------------------------#
# honorable mentions: decimal(for float stuff), cmath(math for complex nums)
#==== MATH
# math: ceil, floor, fabs, fmod, fsum, isclose, isinf isnan isfinite
#       exp, log, log1p, sqrt, sin cos tan, asin/cos/tan/tan2
#       sinh tanh cosh, asinh/cosh/tanh
math.factorial(x) # x!
math.log(16, 4) == 2.0
math.gcd(42, 24) == math.gcd(18, 6) == 6
math.expm1(x) # exp(x) - 1, without loss of precision
math.degrees(angle) # radians --> degrees
math.radians(angle) # degrees --> radians

def phi(x): # cumulative distrib func for the standard norm dist; erf <-- error func
    return (1.0 + math.erf(x / math.sqrt(2.0))) / 2.0

# constants
math.pi  # 3.141592...
math.e   # 2.718281...
math.tau # 6.283185... # circle constant == 2pi, ratio circumference to radius
math.inf # floating point pos infinity == float('inf')
math.nan # fp for NaN == float('nan')


#=== FRACTION
from fractions import Fraction
Fraction(16, -10) == Fraction(-8, 5) # Fraction automatically reduces to rhs
Fraction('3/7')   # Fraction(3, 7)
Fraction('-.125') # Fraction(-1, 8)
Fraction('7e-6')  # Fraction(7, 1000000)
Fraction(2.25)    # Fraction(9, 4)
Fraction(.5) + 2.234  # --> 2.734
from decimal import Decimal
Fraction(1.1) # Fraction(2476979795053773, 2251799813685248)
Fraction(Decimal('1.1')) # Fraction(11, 10)

#=== DECIMAL
# WHY?: decimal module provides support for FAST, CORRECTLY-ROUNDED fp arithmetic
1.1 + 2.2 == 3.3000000000000003
float(Decimal('1.1') + Decimal('2.2')) == 3.3


#==== STATISTICS
statistics.mean(nums)   # what you think
statistics.median(nums) # yep
statistics.median_low([1,3,5,7]) == 3 # USE THIS FOR non-numeric DATA
statistics.median_high([1,3,5,7]) == 5 # USE THIS FOR non-numeric DATA
statistics.variance(data, xbar=None) # xbar is mean of data
statistics.stdev(data, xbar=None) # xbar is mean of data


#==== RANDOM
k = random.randint(a, b) # a <= k <= b; alias randrange(a, b+1)
x = random.random()      # 0.0 <= x < 1.0
y = random.uniform(a, b) # a <= y < b
k = random.randrange(5)  # k in [0,1,2,3,4]; (start, stop) also
random.gauss(mu, sigma) # exactly what you think
# seq
random.choice(seq) # return random elem from seq
random.choices(seq, weights=None, k=3) # select k elem WITH REPLACEMENT
random.sample(seq, k) # select k unique elem from seq, WITHOUT REPLACE
random.shuffle(seq) # shuffle seq IN PLACE


#-----------------------------------------------------------------------------#
#                                   STRING                                    #
#-----------------------------------------------------------------------------#

#==== logging
import logging
>>> logging.basicConfig(format="[%(asctime)s]: %(message)s", datefmt="%Y/%m/%d %H:%M:%S")
>>> logging.warning("Hello friend!")
[2021/03/28 10:32:50]: Hello friend!


#==== f string (and .format)
b = 'baz'; my_float = 2**(1/2);
print(f'{my_float}')     # '1.4142135623730951'
print(f'{my_float:.3f}') # '1.414'
print(f'|{b:<12}|')  # ---> |baz         |
print(f'|{b:^12}|')  # ---> |    baz     |
print(f'|{b:>12}|')  # ---> |         baz|
print(f'|{b:*<12}|') # ---> |baz*********|
print(f'|{b:0^12}|') # ---> |0000baz00000|
print(f'|{b:^>12}|') # ---> |^^^^^^^^^baz|
print(f'{num:03}')   # ---> 007
print(f'{11:03}')    # ---> 011

####--- NEW, PY 3.8.0 f-string `=` feature:
# f"{expr=}" prints 'expr' + '=' + <evaluation of expr>, eg:
A = [1,2,3,4]
my_decimal = Decimal('3.3')
print(f"{A = }")   # ---> A = [1, 2, 3, 4]
print(f"A = {A}")  # ---> A = [1, 2, 3, 4]
print(f"{my_decimal = }")            # ---> my_decimal = Decimal('3.3')
print(f"my_decimal = {my_decimal}")  # ---> my_decimal = 3.3



# str methods
# -----------
#==== Padding and formatting
# case
'OKAY'.lower()  # 'okay'
'quiet'.upper() # 'QUIET'
'chainer'.capitalize() # 'Chainer'
'Hello friend!'.title() # 'Hello Friend!'

# pad
'foo'.center(9)     # '   foo   '
'foo'.ljust(9)      # 'foo      '
'foo'.rjust(9, '+') # '++++++foo'
'california'.center(9) # 'california'
'11'.zfill(5) # '00011'


#==== IS
'123'.isdigit()  # True
'1.23'.isdigit() # False

'Hello123'.isalnum()    # True
'Hello123 '.isalnum()   # False

'Hello'.isalpha() # True; alphabet only True

'Hello there friend! It is 13:13'.isascii()   # True
'Hello there friend! It is 13時13分'.isascii() # False

'an all.123 lower-case string!'.islower() # True
'LOUD VOICES!'.isupper() # True
'Mr. Smith'.istitle() # True
'Chainer'.istitle()    # True
'TensorFlow'.istitle() # False
'Lake Titicaca'.istitle() # True

# OTHER IS METHODS: str.isspace, str.isprintable, str.isidentifier, str.isdecimal


#==== STRIP  str.strip([chars]) : all permutations of chars are stripped
'  hello there  '.strip() # 'hello there'
'https://arxiv.org/pdf/1701.08734.pdf'.strip('htps:/.df') # 'arxiv.org/pdf/1701.08734'
# str.lstrip, str.rstrip also available

#==== STARTSWITH  str.startswith(prefix[,start[,end]])
'https://arxiv.org/pdf/1701.08734.pdf'.startswith('http')   # True
'https://arxiv.org/pdf/1701.08734.pdf'.startswith('arx')    # False
'https://arxiv.org/pdf/1701.08734.pdf'.startswith('arx', 8) # True
#== ENDSWITH
'https://arxiv.org/pdf/1701.08734.pdf'.endswith('pdf') # True

#==== SPLIT  str.split(sep=None, maxsplit=-1)
>>> '/home/evan/Chest/Cheat/py'.split('/')
['', 'home', 'evan', 'Chest', 'Cheat', 'py']

>>> '/home/evan/Chest/Cheat/py'.split('/', maxsplit=3)
['', 'home', 'evan', 'Chest/Cheat/py']

>>> '  mixed    whitespace widths  '.split(' ')
['', '', 'mixed', '', '', '', 'whitespace', 'widths', '', '']

>>> '  mixed    whitespace widths  '.split()
['mixed', 'whitespace', 'widths']
# str.rsplit and str.lsplit also available





#==== STRING
import string
# constants
string.ascii_letters == 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.ascii_lowercase == 'abcdefghijklmnopqrstuvwxyz'
string.ascii_uppercase == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.digits == '0123456789'
string.hexdigits == '0123456789abcdefABCDEF'
string.punctuation == '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
string.whitespace == ' \t\n\r\x0b\x0c'


#-----------------------------------------------------------------------------#
#                                  STL; MISC                                  #
#-----------------------------------------------------------------------------#
"""
Overview of modules available in STL (but not expanded here)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

difflib : matching sequences
    eg difflib.get_close_matches(w, seq) gets words close to w in seq
    can do alot with difflib, can do CLI stuff too

struct : interpret bytes as packed binary data
    have used before for unpacking datasets stored as binaries (nbody sims)

abc : abstract base classes



"""

#=== DATETIME
d = datetime.datetime.now().date() # datetime.date(2019, 2, 28)
d.year; d.month; d.day; # 2019; 2; 28;
str(d) # '2019-02-28'


#==== SECRETS
# random stuff for crypt
secrets.token_hex(12) # '6b0394da5fa4ac285ea8592c'
secrets.token_urlsafe(12) # 'ZuXCa8ummIt8V1-h'
secrets.token_urlsafe()   # 'cZOZlQ4mdwSgfoToQmeHupvRuAVrX-FeG8hSRbeJkrU'



#==== ops
# bitwise
int.bit_length(6) == 3 == len('0b110'[2:])
x | y  # OR
x ^ y  # XOR
x & y  # AND
x << y; x >> y; # shifts
~x # twos comp (bits inverted) == -x - 1

# bytes
(1024).to_bytes(4, 'big') # b'\x00\x00\x04\x00'; hex(1024): 0x400
hex(1000) # '0x3e8'
(1000).to_bytes(4, 'little') # b'\xe8\x03\x00\x00'


#==== BUILTINS
id(s) # returns unique integer identity of object s
divmod(8, 5) == (1, 3) == (8 //5, 8 % 5)
ord('a') == 97 and chr(97) == 'a'
any([0,0,1,0]) == not all([0,0,1,0]) == True

# iter over seq
list(filter(lambda i: i & 1 == 0, [1,2,3,4,5,6])) == [2,4,6]
list(map(lambda i: i - 1, [1,2,3,4])) == [0,1,2,3]

#-----------------------------------------------------------------------------#
#                              PROCESS & THREAD                               #
#-----------------------------------------------------------------------------#


class BiDict(UserDict):
    """A bijective dictionary used for mapping torch <--> trt objects.
    """
    def __delitem__(self, key):
        value = self.data.pop(key)
        self.data.pop(value, None)

    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        self.data[key] = value
        self.data[value] = key

DTYPE_MAPPING = BiDict({torch.int8: trt.int8, torch.int32: trt.int32, torch.float16: trt.float16, torch.float32: trt.float32})
DEVICE_MAPPING = BiDict({torch.device("cuda")})


#-----------------------------------------------------------------------------#
#                                MISC SNIPPETS                                #
#-----------------------------------------------------------------------------#

week_prior_start_date = datetime.datetime.now() - datetime.timedelta(days=7)

#=============================================================================#
#                                                                             #
#             ███████ ████████ ██████         ██      ██ ██████               #
#             ██         ██    ██   ██        ██      ██ ██   ██              #
#             ███████    ██    ██   ██        ██      ██ ██████               #
#                  ██    ██    ██   ██        ██      ██ ██   ██              #
#             ███████    ██    ██████  ██     ███████ ██ ██████               #
#                                                                             #
#=============================================================================#

# stdlib
# ======
# - Text Processing Services
#   - `string` — Common string operations
#   - `re` — Regular expression operations
#   - `difflib` — Helpers for computing deltas
#   - `textwrap` — Text wrapping and filling
#   - `unicodedata` — Unicode Database
#   - `stringprep` — Internet String Preparation
#   - `readline` — GNU readline interface
#   - `rlcompleter` — Completion function for GNU readline
# - Binary Data Services
#   - `struct` — Interpret bytes as packed binary data
#   - `codecs` — Codec registry and base classes
# - Data Types
#   - `datetime` — Basic date and time types
#   - `zoneinfo` — IANA time zone support
#   - `calendar` — General calendar-related functions
#   - `collections` — Container datatypes
#   - `collections.abc` — Abstract Base Classes for Containers
#   - `heapq` — Heap queue algorithm
#   - `bisect` — Array bisection algorithm
#   - `array` — Efficient arrays of numeric values
#   - `weakref` — Weak references
#   - `types` — Dynamic type creation and names for built-in types
#   - `copy` — Shallow and deep copy operations
#   - `pprint` — Data pretty printer
#   - `reprlib` — Alternate `repr()` implementation
#   - `enum` — Support for enumerations
#   - `graphlib` — Functionality to operate with graph-like structures
# - Numeric and Mathematical Modules
#   - `numbers` — Numeric abstract base classes
#   - `math` — Mathematical functions
#   - `cmath` — Mathematical functions for complex numbers
#   - `decimal` — Decimal fixed point and floating point arithmetic
#   - `fractions` — Rational numbers
#   - `random` — Generate pseudo-random numbers
#   - `statistics` — Mathematical statistics functions
# - Functional Programming Modules
#   - `itertools` — Functions creating iterators for efficient looping
#   - `functools` — Higher-order functions and operations on callable objects
#   - `operator` — Standard operators as functions
# - File and Directory Access
#   - `pathlib` — Object-oriented filesystem paths
#   - `os.path` — Common pathname manipulations
#   - `fileinput` — Iterate over lines from multiple input streams
#   - `stat` — Interpreting `stat()` results
#   - `filecmp` — File and Directory Comparisons
#   - `tempfile` — Generate temporary files and directories
#   - `glob` — Unix style pathname pattern expansion
#   - `fnmatch` — Unix filename pattern matching
#   - `linecache` — Random access to text lines
#   - `shutil` — High-level file operations
# - Data Persistence
#   - `pickle` — Python object serialization
#   - `copyreg` — Register `pickle` support functions
#   - `shelve` — Python object persistence
#   - `marshal` — Internal Python object serialization
#   - `dbm` — Interfaces to Unix “databases”
#   - `sqlite3` — DB-API 2.0 interface for SQLite databases
# - Data Compression and Archiving
#   - `zlib` — Compression compatible with **gzip**
#   - `gzip` — Support for **gzip** files
#   - `bz2` — Support for **bzip2** compression
#   - `lzma` — Compression using the LZMA algorithm
#   - `zipfile` — Work with ZIP archives
#   - `tarfile` — Read and write tar archive files
# - File Formats
#   - `csv` — CSV File Reading and Writing
#   - `configparser` — Configuration file parser
#   - `tomllib` — Parse TOML files
#   - `netrc` — netrc file processing
#   - `plistlib` — Generate and parse Apple `.plist` files
# - Cryptographic Services
#   - `hashlib` — Secure hashes and message digests
#   - `hmac` — Keyed-Hashing for Message Authentication
#   - `secrets` — Generate secure random numbers for managing secrets
# - Generic Operating System Services
#   - `os` — Miscellaneous operating system interfaces
#   - `io` — Core tools for working with streams
#   - `time` — Time access and conversions
#   - `argparse` — Parser for command-line options, arguments and sub-commands
#   - `getopt` — C-style parser for command line options
#   - `logging` — Logging facility for Python
#   - `logging.config` — Logging configuration
#   - `logging.handlers` — Logging handlers
#   - `getpass` — Portable password input
#   - `curses` — Terminal handling for character-cell displays
#   - `curses.textpad` — Text input widget for curses programs
#   - `curses.ascii` — Utilities for ASCII characters
#   - `curses.panel` — A panel stack extension for curses
#   - `platform` — Access to underlying platform’s identifying data
#   - `errno` — Standard errno system symbols
#   - `ctypes` — A foreign function library for Python
# - Concurrent Execution
#   - `threading` — Thread-based parallelism
#   - `multiprocessing` — Process-based parallelism
#   - `multiprocessing.shared_memory` — Shared memory for direct access across processes
#   - The `concurrent` package
#   - `concurrent.futures` — Launching parallel tasks
#   - `subprocess` — Subprocess management
#   - `sched` — Event scheduler
#   - `queue` — A synchronized queue class
#   - `contextvars` — Context Variables
#   - `_thread` — Low-level threading API
# - Networking and Interprocess Communication
#   - `asyncio` — Asynchronous I/O
#   - `socket` — Low-level networking interface
#   - `ssl` — TLS/SSL wrapper for socket objects
#   - `select` — Waiting for I/O completion
#   - `selectors` — High-level I/O multiplexing
#   - `signal` — Set handlers for asynchronous events
#   - `mmap` — Memory-mapped file support
# - Internet Data Handling
#   - `email` — An email and MIME handling package
#   - `json` — JSON encoder and decoder
#   - `mailbox` — Manipulate mailboxes in various formats
#   - `mimetypes` — Map filenames to MIME types
#   - `base64` — Base16, Base32, Base64, Base85 Data Encodings
#   - `binascii` — Convert between binary and ASCII
#   - `quopri` — Encode and decode MIME quoted-printable data
# - Structured Markup Processing Tools
#   - `html` — HyperText Markup Language support
#   - `html.parser` — Simple HTML and XHTML parser
#   - `html.entities` — Definitions of HTML general entities
#   - XML Processing Modules
#   - `xml.etree.ElementTree` — The ElementTree XML API
#   - `xml.dom` — The Document Object Model API
#   - `xml.dom.minidom` — Minimal DOM implementation
#   - `xml.dom.pulldom` — Support for building partial DOM trees
#   - `xml.sax` — Support for SAX2 parsers
#   - `xml.sax.handler` — Base classes for SAX handlers
#   - `xml.sax.saxutils` — SAX Utilities
#   - `xml.sax.xmlreader` — Interface for XML parsers
#   - `xml.parsers.expat` — Fast XML parsing using Expat
# - Internet Protocols and Support
#   - `webbrowser` — Convenient web-browser controller
#   - `wsgiref` — WSGI Utilities and Reference Implementation
#   - `urllib` — URL handling modules
#   - `urllib.request` — Extensible library for opening URLs
#   - `urllib.response` — Response classes used by urllib
#   - `urllib.parse` — Parse URLs into components
#   - `urllib.error` — Exception classes raised by urllib.request
#   - `urllib.robotparser` — Parser for robots.txt
#   - `http` — HTTP modules
#   - `http.client` — HTTP protocol client
#   - `ftplib` — FTP protocol client
#   - `poplib` — POP3 protocol client
#   - `imaplib` — IMAP4 protocol client
#   - `smtplib` — SMTP protocol client
#   - `uuid` — UUID objects according to **RFC 4122**
#   - `socketserver` — A framework for network servers
#   - `http.server` — HTTP servers
#   - `http.cookies` — HTTP state management
#   - `http.cookiejar` — Cookie handling for HTTP clients
#   - `xmlrpc` — XMLRPC server and client modules
#   - `xmlrpc.client` — XML-RPC client access
#   - `xmlrpc.server` — Basic XML-RPC servers
#   - `ipaddress` — IPv4/IPv6 manipulation library
# - Multimedia Services
#   - `wave` — Read and write WAV files
#   - `colorsys` — Conversions between color systems
# - Internationalization
#   - `gettext` — Multilingual internationalization services
#   - `locale` — Internationalization services
# - Program Frameworks
#   - `turtle` — Turtle graphics
#   - `cmd` — Support for line-oriented command interpreters
#   - `shlex` — Simple lexical analysis
# - Graphical User Interfaces with Tk
#   - `tkinter` — Python interface to Tcl/Tk
#   - `tkinter.colorchooser` — Color choosing dialog
#   - `tkinter.font` — Tkinter font wrapper
#   - Tkinter Dialogs
#   - `tkinter.messagebox` — Tkinter message prompts
#   - `tkinter.scrolledtext` — Scrolled Text Widget
#   - `tkinter.dnd` — Drag and drop support
#   - `tkinter.ttk` — Tk themed widgets
#   - `tkinter.tix` — Extension widgets for Tk
#   - IDLE
# - Development Tools
#   - `typing` — Support for type hints
#   - `pydoc` — Documentation generator and online help system
#   - Python Development Mode
#   - Effects of the Python Development Mode
#   - ResourceWarning Example
#   - Bad file descriptor error example
#   - `doctest` — Test interactive Python examples
#   - `unittest` — Unit testing framework
#   - `unittest.mock` — mock object library
#   - `unittest.mock` — getting started
#   - 2to3 — Automated Python 2 to 3 code translation
#   - `test` — Regression tests package for Python
#   - `test.support` — Utilities for the Python test suite
#   - `test.support.socket_helper` — Utilities for socket tests
#   - `test.support.script_helper` — Utilities for the Python execution tests
#   - `test.support.bytecode_helper` — Support tools for testing correct bytecode generation
#   - `test.support.threading_helper` — Utilities for threading tests
#   - `test.support.os_helper` — Utilities for os tests
#   - `test.support.import_helper` — Utilities for import tests
#   - `test.support.warnings_helper` — Utilities for warnings tests
# - Debugging and Profiling
#   - Audit events table
#   - `bdb` — Debugger framework
#   - `faulthandler` — Dump the Python traceback
#   - `pdb` — The Python Debugger
#   - The Python Profilers
#   - `timeit` — Measure execution time of small code snippets
#   - `trace` — Trace or track Python statement execution
#   - `tracemalloc` — Trace memory allocations
# - Software Packaging and Distribution
#   - `distutils` — Building and installing Python modules
#   - `ensurepip` — Bootstrapping the `pip` installer
#   - `venv` — Creation of virtual environments
#   - `zipapp` — Manage executable Python zip archives
# - Python Runtime Services
#   - `sys` — System-specific parameters and functions
#   - `sysconfig` — Provide access to Python’s configuration information
#   - `builtins` — Built-in objects
#   - `__main__` — Top-level code environment
#   - `warnings` — Warning control
#   - `dataclasses` — Data Classes
#   - `contextlib` — Utilities for `with`-statement contexts
#   - `abc` — Abstract Base Classes
#   - `atexit` — Exit handlers
#   - `traceback` — Print or retrieve a stack traceback
#   - `__future__` — Future statement definitions
#   - `gc` — Garbage Collector interface
#   - `inspect` — Inspect live objects
#   - `site` — Site-specific configuration hook
# - Custom Python Interpreters
#   - `code` — Interpreter base classes
#   - `codeop` — Compile Python code
# - Importing Modules
#   - `zipimport` — Import modules from Zip archives
#   - `pkgutil` — Package extension utility
#   - `modulefinder` — Find modules used by a script
#   - `runpy` — Locating and executing Python modules
#   - `importlib` — The implementation of `import`
#   - `importlib.resources` – Resources
#   - Deprecated functions
#   - `importlib.resources.abc` – Abstract base classes for resources
#   - Using `importlib.metadata`
#   - The initialization of the `sys.path` module search path
# - Python Language Services
#   - `ast` — Abstract Syntax Trees
#   - `symtable` — Access to the compiler’s symbol tables
#   - `token` — Constants used with Python parse trees
#   - `keyword` — Testing for Python keywords
#   - `tokenize` — Tokenizer for Python source
#   - `tabnanny` — Detection of ambiguous indentation
#   - `pyclbr` — Python module browser support
#   - `py_compile` — Compile Python source files
#   - `compileall` — Byte-compile Python libraries
#   - `dis` — Disassembler for Python bytecode
#   - `pickletools` — Tools for pickle developers
# - MS Windows Specific Services
#   - `msvcrt` — Useful routines from the MS VC++ runtime
#   - `winreg` — Windows registry access
#   - `winsound` — Sound-playing interface for Windows
# - Unix Specific Services
#   - `posix` — The most common POSIX system calls
#   - `pwd` — The password database
#   - `grp` — The group database
#   - `termios` — POSIX style tty control
#   - `tty` — Terminal control functions
#   - `pty` — Pseudo-terminal utilities
#   - `fcntl` — The `fcntl` and `ioctl` system calls
#   - `resource` — Resource usage information
#   - `syslog` — Unix syslog library routines