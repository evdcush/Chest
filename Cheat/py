import os
import sys
import code
import math
import random
from itertools import permutations, combinations, accumulate, reduce

#==== common
matrix = [[0]*ncols for _ in range(nrows)] # BAD_MAT = [[0] * ncols] * nrows # DONT
cond_comp = [i for i in range(20) if i & 1] # get odds
[(i,j) for j in range(5) for i in range(3)] # [(0,0), (1,0), ..., (2,4)]


#==== ops
# bitwise
int.bit_length(6) == 3 == len('0b110'[2:])
x | y  # OR
x ^ y  # XOR
x & y  # AND
x << y; x >> y; # shifts
~x # twos comp (bits inverted) == -x - 1

# bytes
(1024).to_bytes(4, 'big') # b'\x00\x00\x04\x00'; hex(1024): 0x400
hex(1000) # '0x3e8'
(1000).to_bytes(4, 'little') # b'\xe8\x03\x00\x00'




#==== BUILTINS
id(s) # returns unique integer identity of object s
divmod(8, 5) == (1, 3) == (8 //5, 8 % 5)
ord('a') == 97 and chr(97) == 'a'
any([0,0,1,0]) == not all([0,0,1,0]) == True

# iter over seq
list(filter(lambda i: i & 1 == 0, [1,2,3,4,5,6])) == [2,4,6]
list(map(lambda i: i - 1, [1,2,3,4])) == [0,1,2,3]

# int


#==== MATH
math.factorial(x) # x!
math.log(16, 4) == 2.0
math.gcd(42, 24) == math.gcd(18, 6) == 6
math.expm1(x) # exp(x) - 1, without loss of precision

#==== RANDOM
k = random.randint(a, b) # a <= k <= b; alias randrange(a, b+1)
x = random.random()      # 0.0 <= x < 1.0
y = random.uniform(a, b) # a <= y < b
k = random.randrange(5)  # k in [0,1,2,3,4]; (start, stop) also
random.gauss(mu, sigma) # exactly what you think

# seq
random.choice(seq) # return random elem from seq
random.choices(seq, weights=None, k=3) # select k elem WITH REPLACEMENT
random.sample(seq, k) # select k unique elem from seq, WITHOUT REPLACE
random.shuffle(seq) # shuffle seq IN PLACE

