#-----------------------------------------------------------------------------#
#                            argparse subcommands                             #
"""---------------------------------------------------------------------------#
# What is a sub-command?
# ======================
Consider git. Git splits it's functionality into many different
sub-commands, eg: git add, git status, git commit

When you have a program that performs several different functions,
like git, which require different kinds of CL args, you use
sub-commands.

ArgumentParser supports the creation of sub-commands with the
add_subparsers() method. The add_subparsers method is normally called with no arguments,
and returns a special action object.

This object has a single method, add_parser(), which takes
a command name and any ArgumentParser constructor args,
and **returns an ArgumentParser object that can be
modified as usual**.

The following sample code is from
https://mike.depalatis.net/blog/simplifying-argparse.html
"""
from argparse import ArgumentParser

#==== Create parser and subparsers
cli = ArgumentParser()
subparsers = cli.add_subparsers(dest='subcommand')
# dest=<name of attribute under which sub-command name will be stored>
# We store the name of the called subcom so that we can later print help
# if either no subcom is given, or an unrecognized one.

#==== convenience func
def argument(*name_or_flags, **kwargs):
    return (list(names_or_flags), kwargs)

#==== Decorator to turn a func into a subcommand
def subcommand(args=[], parent=subparsers):
    """Decorator to define a new subcommand in a sanity-preserving way.

    The function will be stored in the ``func`` variable when the parser
    parses arguments so that it can be called directly like so::
        args = cli.parse_args()
        args.func(args)

    Usage example::
        @subcommand([argument("-d", help="Enable debug mode", action="store_true")])
        def foo(args):
            print(args)

    Then on the command line::
        $ python cli.py foo -d
    """
    def decorator(func):
        parser = parent.add_parser(func.__name__, description=func.__doc__)
        for arg in args:
            parser.add_argument(*arg[0], **arg[1])
        parser.set_defaults(func=func)
    return decorator

@subcommand()
def nothing(args):
    print("Nothing special!")

#==== main func
if __name__ == '__main__':
    args = cli.parse_args()
    if args.subcommand is None:
        cli.print_help()
    else:
        args.func(args)

#==== Samples
@subcommand([argument('-d', help='debug mod', action='store_true')])
def test(args):
    print(args)

@subcommand([argument('-f', '--filename', help="A thing with a filename")])
def filename(args):
    print(args.filename)

@subcommand([argument('name', help='Name')])
def name(args):
    print(args.name)










```python
# At a glance
# ===========
parser = argparse.ArgumentParser(description='Processing integers.') # description of program
parser.add_argument('integers',  # arg name; if prefixed '-', becomes optional
                    metavar='N', # how the arg is referred in help msg
                    type=int,    # type conversion
                    nargs='+',   # indicates 1 or more vals to be passed to arg
                    help='integer args') # help msg

# parser
# ======
parser = argparse.ArgumentParser(description=__doc__) # uses file __doc__

# arguments
# =========
# an action-like option with a default
add_args('-b', '--baz', nargs='?', default=None, const='x', type=str)

#    Nothing                 Default                        Option
parser.parse_args();  parser.parse_args(['-b']);  parser.parse_args(['-b', '$'])
Namespace(baz=None);  Namespace(baz='x');         Namespace(baz='$')

# 'nargs' arg
nargs='?' # 1 or None values; atomic; can fall back on default if no arg
nargs='*' # 0 or more values;   list; can fall back on default if no arg
nargs='+' # 1 or more values;   list; cannot fall back on default

# restricting choices
add_args('--color', default='green', choices=['red', 'blue', 'yellow', 'green'])

# append
# ======
parser.add_argument('--baz', action='append')
# >>> python aparse.py
# aparse.py: error: argument -b/--baz: expected one argument
# >>> python aparse.py --baz 'hello'
# Namespace(baz=['hello'])
# >>> python aparse.py --baz 'hello' --baz 'there' --baz 'friend'
# Namespace(baz=['hello', 'there', 'friend'])

####  OTHER ARGPARSERS  ####
# Fire
# ====
from fire import Fire

def neg(num):
    return -num

def foo(location='floor'):
    return f'foo on the {location}'

if __name__ == '__main__':
  # Fire()      # both neg and foo available at CLI, but can only use one :[
  # Fire(foo)  # 'fire_example.py airplane' ---> `foo on the airplane`

```

