#-----------------------------------------------------------------------------#
#                                Endemic                                      #
#-----------------------------------------------------------------------------#
# Copy README template to a project dir
function RDME {
    SRC_DIR="$DIR_CHEST_RESOURCES/Templates/README.rst"
    DEST_DIR="$PWD/README.rst"
    cp $SRC_DIR $DEST_DIR
}

dub() {
    dochub $1 -i -d -n;
}

#=============================================================================#
#                                                                             #
#           ,ad8888ba,          db         88           88                    #
#          d8"'    `"8b        d88b        88           88                    #
#         d8'                 d8'`8b       88           88                    #
#         88                 d8'  `8b      88           88                    #
#         88                d8YaaaaY8b     88           88                    #
#         Y8,              d8""""""""8b    88           88                    #
#          Y8a.    .a8P   d8'        `8b   88           88                    #
#           `"Y8888Y"'   d8'          `8b  88888888888  88888888888           #
#                                                                             #
#=============================================================================#

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Lorem ipsum
# ===========
# DEPRECATED: python faker
#li(){lorem-ipsum $@ | xclip -selection clipboard}



# Get bib info
# ============
# DEPRECATED: using my own api now
#function arxbib {
#    arxiv2bib $1 | xclip -selection clipboard
#}



# INBOXING FUNCTIONS
# ==================
#---- git repo hoarding (cloning)
function hurl {
    TARGET='repos'
    URL="$1"
    if [ "$#" -gt 1 ]; then
        #==== "orgs" or "users" specified
        TARGET="$1"
        URL="$2"
    fi
    yq w -i $PATH_INBOX_HOARD "$TARGET"'[+]' $URL
}

#----- Add papers/literature to reading inbox
function rurl {
    #TARGET='arxiv'
    #URL="$1"
    #if [ "$#" -gt 1 ]; then
    #    #==== 'other'
    #    TARGET="$1"
    #    URL="$2"
    #fi
    #yq w -i $PATH_INBOX_READ "$TARGET"'[+]' $URL
    echo $1 >> "$HOME/Cloud/Reading/inbox.txt"
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# ============= #
# miscellaneous #
# ============= #

# Get chrome extension file
#    TODO: function not properly tested. And it's ugly.
#get_crx(){
#    CRXNAME="$1.crx"
#    CRXID="$2"
#    CRX_PATH="$DIR_MEDIA/Software/CRX"
#    A2="crx?response=redirect&acceptformat=crx2,crx3&prodversion=69"
#    A3="&x=id%3D$CRXID%26installsource%3Dondemand%26uc"
#    echo $CRX_PATH
#    wget -O "$CRXNAME" "https://clients2.google.com/service/update2/$A2$A3"
#}

# DEPRECATED: `unar` is used instead
#function extract() {
#    #==== Extract many types of compressed packages
#    if [ -f "$1" ] ; then
#        case "$1" in
#            *.tar.bz2)   tar xvjf "$1"                    ;;
#            *.tar.gz)    tar xvzf "$1"                    ;;
#            *.bz2)       bunzip2 "$1"                     ;;
#            *.rar)       unrar x "$1"                     ;;
#            *.gz)        gunzip "$1"                      ;;
#            *.tar)       tar xvf "$1"                     ;;
#            *.tbz2)      tar xvjf "$1"                    ;;
#            *.tgz)       tar xvzf "$1"                    ;;
#            *.zip)       unzip "$1"                       ;;
#            *.ZIP)       unzip "$1"                       ;;
#            *.pax)       cat "$1" | pax -r                ;;
#            *.pax.Z)     uncompress "$1" â€”stdout | pax -r ;;
#            *.Z)         uncompress "$1"                  ;;
#            *.7z)        7z x "$1"                        ;;
#            *)           echo "don't know how to extract '$1'..." ;;
#        esac
#    else
#        echo "extract: error: $1 is not valid"
#    fi
#}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Add apt repo
# ============
# DEPRECATED: more of a PITA to clip just part of command than just whole cmd
#addrep(){
#    sudo add-apt-repository "ppa:$1" -y
#    sudo apt-fast update
#}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function hurl {
    TARGET='repos'
    URL="$1"
    if [ "$#" -gt 1 ]; then
        #==== "orgs" or "users" specified
        TARGET="$1"
        URL="$2"
    fi
    yq w -i $PATH_INBOX_HOARD "$TARGET"'[+]' $URL
}
#==== leetcode-cli
leet(){
    # leet(int num, str lang=python3): generate leetcode problem num
    # leet 307 --> 307.range-sum-query-mutable.py
    # leet 307 cpp --> 307.range-sum-query-mutable.cpp
    PROBLEM_NUM="$1"
    LANG='python3'
    if [ "$#" -gt 1 ]; then
        LANG="$2"
    fi
    leetcode show $PROBLEM_NUM -gx -l $LANG
}


#=============================================================================#
#                                                                             #
#                88888888888  888b      88  8b           d8                   #
#                88           8888b     88  `8b         d8'                   #
#                88           88 `8b    88   `8b       d8'                    #
#                88aaaaa      88  `8b   88    `8b     d8'                     #
#                88"""""      88   `8b  88     `8b   d8'                      #
#                88           88    `8b 88      `8b d8'                       #
#                88           88     `8888       `888'                        #
#                88888888888  88      `888        `8'                         #
#                                                                             #
#=============================================================================#

# Cython
# ======
#---- full compile of cython from pyx to .so
function cycc(){
    # First get filenames
    FNAME_PYX="$1"  # foo.pyx file
    BASENAME=`echo $FNAME_PYX | cut -d'.' -f1`  # foo
    FNAME_C="$BASENAME.c"   # foo.c
    FNAME_O="$BASENAME.so"  # foo.so

    # Cython compiler:  foo.pyx --> foo.c
    cython "$FNAME_PYX"  # cython compiler

    # C compiler:  foo.c --> foo.so
    gcc -shared -pthread -fPIC -fwrapv -O2 -Wall \
    -fno-strict-aliasing -I/home/evan/.pyenv/versions/3.7.2/include/python3.7m \
    -o "$FNAME_O" "$FNAME_C"
}




# PATH & shell config
# ===================

#---- reset PATH to default
function reset_path(){
    echo "Resetting Path...\n--------------------------------------------------"
    echo "  current path = $PATH\n"
    PATH="$PATH_DEFAULT"  # in 'path' dots
    #PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    #PATH=$(getconf PATH)
    echo "  reset path = $PATH\n"
    source ~/.zshrc
    echo "--------------------------------------------------"
}

##---- add line to shell config
# DEPRECATED: almost never used
#function expzsh(){
#    echo "\n\n#==== $1" >> ~/.zshrc
#    echo "$2" >> ~/.zshrc
#}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Make new pyenv virtualenv
# =========================
function pvenv(){
    if [ "$#" -gt 1 ]; then
        #==== python version specified
        PY_VER="$1"
        VENV_NAME="$2"
    else
        #==== default latest python ver (3.7)
        PY_VER='3.7.2'
        VENV_NAME="$1"
    fi
    #==== Make virtualenv
    pyenv virtualenv "$PY_VER" "$VENV_NAME"
    pyenv local "$VENV_NAME"
    #==== Update base packages
    pip install -U pip setuptools wheel
}

#=============================================================================#
#                                                                             #
#   ad88888ba   88        88  88        88  888888888888  88  88              #
#  d8"     "8b  88        88  88        88       88       88  88              #
#  Y8,          88        88  88        88       88       88  88              #
#  `Y8aaaaa,    88aaaaaaaa88  88        88       88       88  88              #
#    `"""""8b,  88""""""""88  88        88       88       88  88              #
#          `8b  88        88  88        88       88       88  88              #
#  Y8a     a8P  88        88  Y8a.    .a8P       88       88  88              #
#   "Y88888P"   88        88   `"Y8888Y"'        88       88  88888888888     #
#                                                                             #
#=============================================================================#

# dir and file stuff
# ==================

#==== Diff files in the manner of git diff
function gdiff () { diff -u $@ | colordiff | less -R; }

#==== mkdir & cd into it
function mcd(){mkdir -p "$1" && cd "$1"}

#==== cd & list contents
function cdl(){cd "$1" && ls -1FSshX --file-type}

# symlink something to ~/.local/bin
function lnbin(){
    # make thing executable
    chmod +x "$1"
    # Set paths
    SRC="$PWD/$1"
    #DEST="$PATH_USER_BIN"
    DEST="$HOME/.local/bin"
    if [ "$#" -gt 1 ]; then
        # rename link endpoint
        #DEST="$PATH_USER_BIN/$2"
        DEST="$DEST/$2"
    fi
    # link it up (NB: -r converts abs symlinks to rel)
    #ln -sfr $SRC $DEST
    ln -sf $SRC $DEST
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Finding stuff
# =============
function find_and_remove_all(){
    matches=$(sudo find / -iname "*$1*")
    echo "$matches"
    echo -n "Do you want to proceed (y/N)? "
    read answer
    if [ "$answer" != "${answer#[Yy]}" ] ;then
        echo "Proceeding to remove all matches..."
        sudo find / -iname "*$1*" -exec rm -rf "{}" \;
        echo "Finished removal"
    else
        echo "ABORTED"
    fi
}

# Shortcut find
# =============
function f(){
    if [ "$#" -gt 1 ]; then
        #=== find location specified
        find "$1" -iname "*$2*"
    else
        #==== find from root
        sudo find / -iname "*$1*"
    fi
}

# Timezone diff
# =============
function jst2pst(){
    # *** ASSUMES SYSTEM tz IS PST ***
    _TIME="$1"
    _DATE="$2"
    JST='TZ="Asia/Tokyo"'
    # Sample call:
    # date --date='TZ="Asia/Tokyo" 09:00 2/1'
    date --date="$JST $_TIME $_DATE"
}

#=============================================================================#
#                                                                             #
#                        ,ad8888ba,   88  888888888888                        #
#                       d8"'    `"8b  88       88                             #
#                      d8'            88       88                             #
#                      88             88       88                             #
#                      88      88888  88       88                             #
#                      Y8,        88  88       88                             #
#                       Y8a.    .a88  88       88                             #
#                        `"Y88888P"   88       88                             #
#                                                                             #
#=============================================================================#
#https://api.github.com/repos/willsALMANJ/Zutilo/releases/latest
# Get latest release
# ==================
# NB: this assumes whatever target asset you want is
#     the first asset listed in release
function gh-release(){
    if [ "$#" -eq 0 ]; then
        args=`xclip -o -selection clipboard` # NB: wrapping bash statement in backticks makes var = statement ret
    else
        args=$1
    fi
    splitargs=`echo $args | tr "/" "\n" | tail -n 2`
    read -d "\n" GH_USER GH_REPO <<<$splitargs
    #echo $GH_USER
    #echo $GH_REPO
    api_url="https://api.github.com/repos/$GH_USER/$GH_REPO/releases/latest"
    curl $api_url | jq '.assets | .[0] | .browser_download_url' | xargs wget
}


# git clone && cd
function gcd(){
    REPO_URL=$1
    git clone --depth=1 $REPO_URL
    cdl "$(basename $1 .git)"
}


# Scorched earth
# ==============
function git-nuke(){
    #=== nuke targets
    TARGETS=$@
    echo -n "WARNING: git-nuke called on $TARGETS, do you want to proceed? (y/N): "
    read launch_confirmation
    if [ "$launch_confirmation" != "${launch_confirmation#[Yy]}" ] ;then
        echo "Proceeding to nuke"
        echo "NOTE: current .git is saved as GITBKP in case of SNAFU, and must removed manually\n"
        cp -r .git GITBKP

        #=== Delete specified files from hist
        git filter-branch --force --index-filter \
        "git rm --cached --ignore-unmatch $TARGETS" \
        --prune-empty --tag-name-filter cat -- --all

        #=== Cleanup refs
        git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
        git reflog expire --expire=now --all
        git gc --aggressive --prune=now

        #=== Push changes
        echo -n "\n\tLocal repo nuked; Do you want to force push to remote? (y/N): "
        read push_confirmation
        if [ "$push_confirmation" != "${push_confirmation#[Yy]}" ] ;then
            git push --all --prune --force  # will delete all branches not in local
        else
            echo "/tREMOTE PUSH ABORT\n\tNB: local git changes persist"
            echo "To restore git to pre-nuke state:"
            echo 'rm -rf .git; mv GITBKP .git; git reset HEAD --hard'
        fi
    else
        echo "/tNUCLEAR STRIKE CANCELED"
    fi
}


