
#-----------------------------------------------------------------------------#
#                                PATHS                                        #
#-----------------------------------------------------------------------------#


#-----------------------------------------------------------------------------#
#                                Endemic                                      #
#-----------------------------------------------------------------------------#

#  DEPRECATED; using jrnl now instead
#==== write line to D log
#dw(){
#    D_FPATH="$HOME/D"
#    echo "$1" >> "$HOME/D"
#}

# UNUSED *****NEED BETTER SOLUTION******
#   >>----> Consider echoing a list? Just use jrnl tags? Look into goog Keep API?
#==== write line to look n2 log
# n2(){
#     N2_FPATH="$DIR_DOCS/n2.md"
#     echo " * $@" >> "$N2_FPATH"
# }

#-----------------------------------------------------------------------------#
#                            Apps & Scripts                                   #
#-----------------------------------------------------------------------------#

# Nativefier
# ==========
nativefy(){
    python "$DIR_CHEST_CODE/Scripts/nativefy.py" "$@"
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# INBOXING FUNCTIONS
# ==================

#---- Github repo hoarding (cloning)
function hurl {
ARGS="$@" IPATH="$PATH_INBOX_HOARD" python - <<END
import os
import yaml

#==== Read STDIN
path_inbox = str(os.environ['IPATH'])
args_input = os.environ['ARGS'].split(' ')

#==== Process args
has_flag  = len(args_input) > 1
flag, url = args_input if has_flag else ('r', args_input.pop())

#==== Get key
key_map = dict(r="repos", o="orgs", u="users")
key = key_map[flag]

#==== Get inbox file
with open(path_inbox, 'r') as file_inbox:
    inbox = yaml.load(file_inbox)

#==== Update inbox
inbox[key].append(url) # NB: duplicate entries managed by hoarding script
print(f'SAVED: inbox[{key}].append({url})')
with open(path_inbox, 'w') as file_inbox:
    yaml.dump(inbox, file_inbox, default_flow_style=False)
END
}

#----- Add papers/literature to reading inbox
function rurl {
ARGS="$@" IPATH="$PATH_INBOX_READ" python - <<END
import os
import yaml

#==== Read STDIN
path_inbox = str(os.environ['IPATH'])
url = os.environ['ARGS']

#==== Process args
# ==========
if 'arxiv.org' in url:
    key = 'arxiv'
    val = url.strip('htps:/arxiv.ogbdf')   # extracts arxiv ID
else:
    key = 'other'
    val = url

#==== Get inbox file
with open(path_inbox, 'r') as file_inbox:
    inbox = yaml.load(file_inbox)

#==== Update inbox
inbox[key].append(val)
with open(path_inbox, 'w') as file_inbox:
    yaml.dump(inbox, file_inbox, default_flow_style=False)
END
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Chrome stuff
# ============

# Get chrome extension
get_crx(){
    CRXNAME="$1.crx"
    CRXID="$2"
    CRX_PATH="$DIR_SOFTWARE/CRX/$CRXNAME"
    wget "https://clients2.google.com/service/update2/crx?response=redirect&acceptformat=crx2,crx3&prodversion=69&x=id%3D$CRXID%26installsource%3Dondemand%26uc -O $CRX_PATH"
}

#-----------------------------------------------------------------------------#
#                        Shell Utils & Shortcuts                              #
#-----------------------------------------------------------------------------#


# PATH & shell config
# ===================

#---- reset PATH to default
function reset_path(){
    echo "Resetting Path...\n--------------------------------------------------"
    echo "  current path = $PATH\n"
    PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    #PATH=$(getconf PATH)
    echo "  reset path = $PATH\n"
    source ~/.zshrc
    echo "--------------------------------------------------"
}


#---- source zshrc
function srcz(){
    reset_path # sourcing can duplicate parts of PATH anyway, so just reset
    #source ~/.zshrc
}

#---- add line to shell config
function expzsh(){
    #expzsh 'My alias' 'alias testalias="echo test passed"'
    echo "\n\n#==== $1" >> ~/.zshrc
    echo "$2" >> ~/.zshrc
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#==== Extract many types of compressed packages
function extract() {
    if [ -f "$1" ] ; then
        case "$1" in
            *.tar.bz2)   tar xvjf "$1"                    ;;
            *.tar.gz)    tar xvzf "$1"                    ;;
            *.bz2)       bunzip2 "$1"                     ;;
            *.rar)       unrar x "$1"                     ;;
            *.gz)        gunzip "$1"                      ;;
            *.tar)       tar xvf "$1"                     ;;
            *.tbz2)      tar xvjf "$1"                    ;;
            *.tgz)       tar xvzf "$1"                    ;;
            *.zip)       unzip "$1"                       ;;
            *.ZIP)       unzip "$1"                       ;;
            *.pax)       cat "$1" | pax -r                ;;
            *.pax.Z)     uncompress "$1" â€”stdout | pax -r ;;
            *.Z)         uncompress "$1"                  ;;
            *.7z)        7z x "$1"                        ;;
            *)           echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "extract: error: $1 is not valid"
    fi
}

# Diff files in the matter of git diff
function gdiff () { diff -u $@ | colordiff | less -R; }

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Directory functions
#--------------------
#==== mkdir & cd into it
function mcd(){mkdir -p "$1" && cd "$1"}

#==== cd & list contents
function cdl(){cd "$1" && ls -1FSshX --file-type}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Finding stuff

# Find and delete: CAREFUL
#=========================
function find_and_remove_all(){
    matches=$(sudo find / -iname "*$1*")
    echo matches
    echo -n "Do you want to proceed (y/n)? "
    read answer
    if [ "$answer" = "${answer#[Yy]}" ] ;then
        echo ""
        sudo find / -iname "*$1*" -exec rm -rf "{}" \;
    else
        echo Aborted
    fi
}

# Shortcut find
# =============
function f(){
    if [ "$#" -gt 1 ]; then
        sudo find "$1" -iname "$2"
    else
        sudo find / -iname "$1"
    fi
}


#-----------------------------------------------------------------------------#
#                             Package Utils                                   #
#-----------------------------------------------------------------------------#

#==== add apt-repo
addrep(){
    sudo add-apt-repository "ppa:$1" -y
    sudo apt-fast update
}


# Make new pyenv virtualenv
#========================
pvenv(){
    if [ "$#" -gt 1 ]; then
        PY_VER=$1
        VENV_NAME=$2
    else
        PY_VER='3.7.1'
        VENV_NAME="$1"
    fi
    # Make venv
    pyenv virtualenv "$PY_VER" "$VENV_NAME"
    pyenv local "$VENV_NAME"
    # Update base packages
    pip install -U pip setuptools wheel
}


#-----------------------------------------------------------------------------#
#                            git related                                      #
#-----------------------------------------------------------------------------#

# git clone && cd
# ===============
function gcd(){
    REPO_URL=$1
    git clone --depth=1 $REPO_URL
    cdl "$(basename $1 .git)"
}

# Grab stars from user
# ====================
getstars(){
    # if user specified, get their stars, else get mine
    USER=${1:-'evdcush'}   # slickkkkkkkkkkkkkkkkkkkkkkk, love this "parameter expansion" op
    TOKEN="$TOKEN_GH_SCRAPE"
    starred --username "$USER" --sort --token "$TOKEN" > "$USER.stars.md"
}
